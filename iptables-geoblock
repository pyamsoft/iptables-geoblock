#!/bin/sh

# The GPLv2 License
#
#   Copyright (C) 2025 pyamsoft
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

readonly PROGRAM="iptables-geoblock"
readonly VERSION="0.0.5"

readonly _CHAIN_NAME="IPTABLES_GEOBLOCK"
readonly _LOGDROP_CHAIN="${_CHAIN_NAME}-LOGDROP"

readonly CONFIG_DIR="${CONFIG_DIR:-/etc/iptables-geoblock}"

readonly _ACCEPT_COUNTRIES=""

readonly _ACCEPT_IP4="127.0.0.1/8"
readonly _ACCEPT_IP6="::1/128"

readonly _BLOCK_IP4=""
readonly _BLOCK_IP6=""

_log() {
  _msg="$1"
  shift

  printf -- "[%s]: ${_msg}\n" "${PROGRAM}" "$@" || return 1

  unset _msg
  return 0
}

_remove_rule() {
  if "${_ip}" -C "$@" >/dev/null 2>&1; then
    _log 'Remove rule: %s -D %s' "${_ip}" "$*"
    "${_ip}" -D "$@" || return 1
  fi

  return 0
}

_append_rule_if_not_exists() {
  if ! "${_ip}" -C "$@" >/dev/null 2>&1; then
    _log 'Appending new rule: %s -I %s' "${_ip}" "$*"
    "${_ip}" -A "$@" || return 1
  fi

  return 0
}

_insert_rule_if_not_exists() {
  if ! "${_ip}" -C "$@" >/dev/null 2>&1; then
    _log 'Inserting new rule: %s -I %s' "${_ip}" "$*"
    "${_ip}" -I "$@" || return 1
  fi

  return 0
}

_erase_chain() {
  _name="$1"

  _log 'Zeroing chain: %s --zero %s' "${_ip}" "${_name}"
  "${_ip}" --zero "${_name}" || {
    unset _name
    return 1
  }

  _log 'Flushing chain: %s --flush %s' "${_ip}" "${_name}"
  "${_ip}" --flush "${_name}" || {
    unset _name
    return 1
  }

  unset _name
  return 0
}

_apply_chain_defaults() {
  # Drop invalid traffic
  _append_rule_if_not_exists "${_CHAIN_NAME}" -m conntrack --ctstate INVALID -j DROP || return 1

  # Accept related/established traffic
  _append_rule_if_not_exists "${_CHAIN_NAME}" -m conntrack --ctstate RELATED,ESTABLISHED -j RETURN || return 1

  return 0
}

# DHCPv6 REQUIRES that certain traffic be ALLOWED
_apply_chain_dhcp6() {
  # Accept DHCPv6 traffic
  _append_rule_if_not_exists "${_CHAIN_NAME}" -s fe80::/10 -p udp --sport 547 --dport 546 -j RETURN || return 1

  # Neighbor Discovery
  _append_rule_if_not_exists "${_CHAIN_NAME}" -p ipv6-icmp --icmpv6-type 135 -j RETURN
  _append_rule_if_not_exists "${_CHAIN_NAME}" -p ipv6-icmp --icmpv6-type 136 -j RETURN

  # Router Advertisement (SLAAC)
  _append_rule_if_not_exists "${_CHAIN_NAME}" -p ipv6-icmp --icmpv6-type 134 -j RETURN

  # Redirect
  _append_rule_if_not_exists "${_CHAIN_NAME}" -p ipv6-icmp --icmpv6-type 137 -j RETURN

  return 0
}

_prepare_logdrop() {
  _append_rule_if_not_exists "${_LOGDROP_CHAIN}" -j LOG --log-prefix "[${_CHAIN_NAME}]: " || return 1
  _append_rule_if_not_exists "${_LOGDROP_CHAIN}" -j DROP || return 1

  return 0
}

_nomatch_logdrop() {
  _append_rule_if_not_exists "${_CHAIN_NAME}" -j "${_LOGDROP_CHAIN}" || return 1

  return 0
}

_source_configs() {
  if [ -d "${CONFIG_DIR}" ]; then
    if [ "${_ip}" = "iptables" ]; then
      # IPv4 allowlist config
      for _conf in "${CONFIG_DIR}"/*".allow.4"; do
        # If there were no matching configuration files, do nothing
        if [ ! -e "${_conf}" ]; then
          _log 'No configuration for IPv4 Allowlist found.'
          break
        fi

        # Otherwise source the config
        if [ -r "${_conf}" ]; then
          # Trim out all blank or comment lines
          # We must read this way from an EOF posix-sh heredoc otherwise
          # this while-loop happens in a subshell which causes the variable write
          # to not be saved
          while IFS="" read -r _i4 || [ -n "${_i4}" ]; do
            if [ -z "${_ALL_ACCEPT_IP4}" ]; then
              _ALL_ACCEPT_IP4="${_i4}"
            else
              _ALL_ACCEPT_IP4="${_ALL_ACCEPT_IP4} ${_i4}"
            fi
            unset _i4
          done <<EOF
$(grep -v '^#' "${_conf}")
EOF
          unset _i4
        fi

        unset _conf
      done
      unset _conf

      # IPv4 blocklist config
      for _conf in "${CONFIG_DIR}"/*".block.4"; do
        # If there were no matching configuration files, do nothing
        if [ ! -e "${_conf}" ]; then
          _log 'No configuration for IPv4 Blocklist found.'
          break
        fi

        # Otherwise source the config
        if [ -r "${_conf}" ]; then
          # Trim out all blank or comment lines
          # We must read this way from an EOF posix-sh heredoc otherwise
          # this while-loop happens in a subshell which causes the variable write
          # to not be saved
          while IFS="" read -r _i4 || [ -n "${_i4}" ]; do
            if [ -z "${_ALL_BLOCK_IP4}" ]; then
              _ALL_BLOCK_IP4="${_i4}"
            else
              _ALL_BLOCK_IP4="${_ALL_BLOCK_IP4} ${_i4}"
            fi
            unset _i4
          done <<EOF
$(grep -v '^#' "${_conf}")
EOF
          unset _i4
        fi

        unset _conf
      done
      unset _conf
    fi

    if [ "${_ip}" = "ip6tables" ]; then
      # IPv6 allowlist config
      for _conf in "${CONFIG_DIR}"/*".allow.6"; do
        # If there were no matching configuration files, do nothing
        if [ ! -e "${_conf}" ]; then
          _log 'No configuration for IPv6 Allowlist found.'
          break
        fi

        # Otherwise source the config
        if [ -r "${_conf}" ]; then
          # Trim out all blank or comment lines
          # We must read this way from an EOF posix-sh heredoc otherwise
          # this while-loop happens in a subshell which causes the variable write
          # to not be saved
          while IFS="" read -r _i6 || [ -n "${_i6}" ]; do
            if [ -z "${_ALL_ACCEPT_IP6}" ]; then
              _ALL_ACCEPT_IP6="${_i6}"
            else
              _ALL_ACCEPT_IP6="${_ALL_ACCEPT_IP6} ${_i6}"
            fi
            unset _i6
          done <<EOF
$(grep -v '^#' "${_conf}")
EOF
          unset _i6
        fi

        unset _conf
      done
      unset _conf

      # IPv6 blocklist config
      for _conf in "${CONFIG_DIR}"/*".block.6"; do
        # If there were no matching configuration files, do nothing
        if [ ! -e "${_conf}" ]; then
          _log 'No configuration for IPv6 Blocklist found.'
          break
        fi

        # Otherwise source the config
        if [ -r "${_conf}" ]; then
          # Trim out all blank or comment lines
          # We must read this way from an EOF posix-sh heredoc otherwise
          # this while-loop happens in a subshell which causes the variable write
          # to not be saved
          while IFS="" read -r _i6 || [ -n "${_i6}" ]; do
            if [ -z "${_ALL_BLOCK_IP6}" ]; then
              _ALL_BLOCK_IP6="${_i6}"
            else
              _ALL_BLOCK_IP6="${_ALL_BLOCK_IP6} ${_i6}"
            fi
            unset _i6
          done <<EOF
$(grep -v '^#' "${_conf}")
EOF
          unset _i6
        fi

        unset _conf
      done
      unset _conf
    fi

    # Country allowlist config
    for _conf in "${CONFIG_DIR}"/*".allow.country"; do
      # If there were no matching configuration files, do nothing
      if [ "${_conf}" = "${CONFIG_DIR}/*.allow.country" ]; then
        _log 'No configuration for Country Allowlist found.'
        break
      fi

      # Otherwise source the config
      if [ -r "${_conf}" ]; then
        # Trim out all blank or comment lines
        # We must read this way from an EOF posix-sh heredoc otherwise
        # this while-loop happens in a subshell which causes the variable write
        # to not be saved
        while IFS="" read -r _ic || [ -n "${_ic}" ]; do
          if [ -z "${_ALL_ACCEPT_COUNTRIES}" ]; then
            _ALL_ACCEPT_COUNTRIES="${_ic}"
          else
            _ALL_ACCEPT_COUNTRIES="${_ALL_ACCEPT_COUNTRIES} ${_ic}"
          fi
          unset _ic
        done <<EOF
$(grep -v '^#' "${_conf}")
EOF
        unset _ic
      fi

      unset _conf
    done
    unset _conf
  fi

  return 0
}

_prepare_lists() {
  _ALL_ACCEPT_IP4="${_ACCEPT_IP4}"
  _ALL_ACCEPT_IP6="${_ACCEPT_IP6}"
  _ALL_ACCEPT_COUNTRIES="${_ACCEPT_COUNTRIES}"

  _ALL_BLOCK_IP4="${_BLOCK_IP4}"
  _ALL_BLOCK_IP6="${_BLOCK_IP6}"

  # Read from configuration if they exist
  _source_configs || {
    _log 'Failed to source configuration from %s' "${CONFIG_DIR}"
    return 1
  }

  return 0
}

_apply_blocklist() {
  if [ "${_ip}" = "iptables" ]; then
    # Block any bad IPv4 address
    if [ -n "${_ALL_BLOCK_IP4}" ]; then
      for _c in ${_ALL_BLOCK_IP4}; do
        _log 'Block IPv4: %s' "${_c}"
        _append_rule_if_not_exists "${_CHAIN_NAME}" --source "${_c}" -j "${_LOGDROP_CHAIN}" || {
          _log 'Failed to block IPv4: %s' "${_c}"
        }
      done
    else
      _log 'No IPv4 addresses to block.'
    fi
  fi

  if [ "${_ip}" = "ip6tables" ]; then
    # Block any bad IPv6 address
    if [ -n "${_ALL_BLOCK_IP6}" ]; then
      for _c in ${_ALL_BLOCK_IP6}; do
        _log 'Block IPv6: %s' "${_c}"
        _append_rule_if_not_exists "${_CHAIN_NAME}" --source "${_c}" -j "${_LOGDROP_CHAIN}" || {
          _log 'Failed to block IPv6: %s' "${_c}"
        }
      done
    else
      _log 'No IPv6 addresses to block.'
    fi
  fi

  return 0
}

_apply_allowlist_ips() {
  if [ "${_ip}" = "iptables" ]; then
    # Accept any good IPv4 address
    if [ -n "${_ALL_ACCEPT_IP4}" ]; then
      for _c in ${_ALL_ACCEPT_IP4}; do
        _log 'Allow IPv4: %s' "${_c}"
        _append_rule_if_not_exists "${_CHAIN_NAME}" --source "${_c}" -j RETURN || {
          _log 'Failed to allow IPv4: %s' "${_c}"
        }
      done
    else
      _log 'No IPv4 addresses to allow.'
    fi
  fi

  if [ "${_ip}" = "ip6tables" ]; then
    # Accept any good IPv6 address
    if [ -n "${_ALL_ACCEPT_IP6}" ]; then
      for _c in ${_ALL_ACCEPT_IP6}; do
        _log 'Allow IPv6: %s' "${_c}"
        _append_rule_if_not_exists "${_CHAIN_NAME}" --source "${_c}" -j RETURN || {
          _log 'Failed to allow IPv6: %s' "${_c}"
        }
      done
    else
      _log 'No IPv6 addresses to allow.'
    fi
  fi

  return 0
}

_apply_allowlist_countries() {
  # Accept any good countries
  if [ -n "${_ALL_ACCEPT_COUNTRIES}" ]; then
    for _c in ${_ALL_ACCEPT_COUNTRIES}; do
      _log 'Accept traffic from country: %s' "${_c}"
      _append_rule_if_not_exists "${_CHAIN_NAME}" -m geoip --src-cc "${_c}" -j RETURN || {
        _log 'Failed to allow country: %s' "${_c}"
      }
    done
  else
    _log '!!! No Countries to allow! You are blocking all traffic !!!'
  fi

  return 0
}

_setup_chains() {
  _prepare_logdrop || {
    _log 'Failed to prepare logdrop chain %s' "${_LOGDROP_CHAIN}"
    return 1
  }

  _prepare_lists || {
    _log 'Failed to prepare IP lists'
    return 1
  }

  _apply_chain_defaults || {
    _log 'Failed to apply chain defaults %s' "${_CHAIN_NAME}"
    return 1
  }

  if [ "${_ip}" = "ip6tables" ]; then
    _apply_chain_dhcp6 || {
      _log 'Failed to apply chain DHCPv6 %s' "${_CHAIN_NAME}"
      return 1
    }
  fi

  _apply_allowlist_ips || {
    _log 'Failed applying allowlist IPs to chain %s' "${_CHAIN_NAME}"
    return 1
  }

  _apply_blocklist || {
    _log 'Failed applying blocklist to chain %s' "${_CHAIN_NAME}"
    return 1
  }

  _apply_allowlist_countries || {
    _log 'Failed applying allowlist countries to chain %s' "${_CHAIN_NAME}"
    return 1
  }

  # Otherwise drop
  _nomatch_logdrop || {
    _log 'Failed final nomatch-logdrop setup for %s' "${_CHAIN_NAME}"
    return 1
  }

  return 0
}

_ensure_chain() {
  _ensure_chain_name="$1"

  if "${_ip}" --new-chain "${_ensure_chain_name}" >/dev/null 2>&1; then
    _log 'Create new chain: %s' "${_ensure_chain_name}"
  else
    _log 'Refresh existing chain: %s' "${_ensure_chain_name}"
  fi

  unset _ensure_chain_name
  return 0
}

_reset_chains_to_default_state() {
  _remove_rule INPUT -j "${_CHAIN_NAME}" || return 1

  _erase_chain "${_CHAIN_NAME}" || return 1
  _erase_chain "${_LOGDROP_CHAIN}" || return 1
}

_iptables_apply() {
  _apply_opts="$1"

  _ensure_chain "${_CHAIN_NAME}"
  _ensure_chain "${_LOGDROP_CHAIN}"

  _reset_chains_to_default_state || {
    unset _apply_opts
    return 1
  }

  _setup_chains || {
    unset _apply_opts
    return 1
  }

  # Since we use insert, add these in reverse order
  _insert_rule_if_not_exists INPUT -j "${_CHAIN_NAME}" || {
    unset _apply_opts
    return 1
  }

  unset _apply_opts
  return 0
}

_iptables_clear() {
  _clear_opts="$1"

  _reset_chains_to_default_state || {
    unset _clear_opts
    return 1
  }

  # Delete chains
  _log 'Delete leftover chain %s' "${_CHAIN_NAME}"
  "${_ip}" --delete-chain "${_CHAIN_NAME}" >/dev/null 2>&1 || {
    _log 'Failed to delete chain %s' "${_CHAIN_NAME}"
    return 1
  }

  unset _clear_opts
  return 0
}

_parse_cmd() {
  # Global __command exists
  if [ -z "$1" ]; then
    _log 'Must specify one of "apply" "clear"'
    return 1
  fi

  case "$1" in
  "apply" | "clear")
    __command="$1"
    ;;
  *)
    _log 'Must specify one of "apply" "clear": %s' "$1"
    return 1
    ;;
  esac

  return 0
}

_exec_cmd() {
  _cmd="$1"
  _opts="$2"

  if [ -z "${_cmd}" ]; then
    _log 'Must specify one of "apply" "clear"'
    _usage || return 1

    unset _cmd
    unset _opts
    return 1
  fi

  if [ "${_cmd}" = "apply" ]; then
    _iptables_apply "${_opts}" || {
      _log 'Failed to apply iptables rules. Clean up and exit(1)'
      _iptables_clear "${_opts}" || return 1
      return 1
    }
  elif [ "${_cmd}" = "clear" ]; then
    _iptables_clear "${_opts}" || return 1
  else
    _log 'Unknown execute command: %s (%s)' "${_cmd}" "${_opts}"
    _usage || return 1

    unset _cmd
    unset _opts
    return 1
  fi

  unset _cmd
  unset _opts
  return 0
}

_parse_ipv() {
  if [ -z "$1" ]; then
    _log 'Must specify one of "4" "6"'
    return 1
  fi

  if [ "$1" = "4" ]; then
    _ip="iptables"
  elif [ "$1" = "6" ]; then
    _ip="ip6tables"
  else
    _log 'Must specify one of "4" "6": %s' "$1"
    return 1
  fi

  # Check exists
  if ! command -v "${_ip}" >/dev/null; then
    _log 'Must have "%s" installed.' "${_ip}"
    return 1
  fi

  # Do not touch!
  readonly _ip
  return 0
}

_usage() {
  _log '%s' "$(
    cat <<EOF
${VERSION}

${PROGRAM} <4|6> <apply|clear>

4           operate on IPv4 (iptables)
6           operate on IPv6 (ip6tables)

apply       Apply geoblocking rules
clear       Clear geoblocking rules
EOF
  )"
}

main() {
  if [ "$(id -u)" -ne 0 ]; then
    _log 'Must run as root.'
    _usage || return 1
    return 1
  fi

  # We need grep
  if ! command -v "grep" >/dev/null; then
    _log 'Must have "grep" installed.'
    _usage || return 1
    return 1
  fi

  _parse_ipv "$1" || {
    _usage || return 1
    return 1
  }
  shift

  __command=""
  _parse_cmd "$1" || {
    _usage || return 1
    return 1
  }
  shift

  _exec_cmd "${__command}" "$@" || return 1

  return 0
}

main "$@" || exit 1
exit 0
